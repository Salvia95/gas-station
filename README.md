# 주유소 관리 시스템(Gas Station Management System)
실무에서 마주한 문제 상황과 앞으로 마주할 것이 예상되는 문제 사항에 대한 해결을 위해 레거시 시스템의 구조적, 기술적 한계를 분석하고 **현대적 기술 스택과 아키텍처를 적용해 재설계한 프로젝트** 입니다.
## 목차

1. [프로젝트 동기](#프로젝트-동기)
2. [이 프로젝트의 궁극적인 목표](#이-프로젝트의-궁극적인-목표)
3. [기술 스택 변경 사항](#기술-스택-변경-사항)
4. [아키텍처 변경 사항](#아키텍처-변경-사항)
5. [프로젝트의 범위와 제약 사항](#프로젝트의-범위와-제약사항)
6. [개발 프로세스](#개발-프로세스)
7. [실행 방법](#실행-방법)
## 프로젝트 동기
### 1. 실무에서 마주한 문제에 대한 근본적인 해결
Java 11, Spring Framework 5.X, Oracle 12c, Mybatis를 사용하고 있는 레거시 시스템을 유지보수하는 과정에서 마주했던 **대다수의 문제는 기존 기술 스택 안에서 해결**할 수 있었습니다.

허나, 기존 기술 스택 안에서 해결할 수 없었던 혹은 해결을 위해 과도하게 많은 공수가 투입되어야 했던 **시스템의 구조적인 문제**, **지속적으로 떨어지는 개발 생산성**, **지수적으로 증가하고 있는 기술 부채**의 문제는 **근본적으로 해결되지 않고 있었습니다.**

그 누구도 이를 해결할 수 있다고 말하거나, 해결해보고자 하는 시도를 하고 있지 않았기에 자연스럽게 궁금증이 생기게 되었습니다.

> ***"정말 해결이 불가능한 걸까? 아니면 시도하지 않았을 뿐인 걸까?"***  

저는 이 질문에 대한 해답을 직접 찾아보기 위해 문제 해결을 통해 **대부분의 문제가 해결 불가능 한 것이 아니라, 해결 방법을 아직 찾지 못하거나, 시도해보지 않은 것 뿐이란 것을 증명**하고자 본 프로젝트를 기획하게 되었습니다.
### 2. 변화를 설득하기 위한 근거의 필요성 실감
조직과 시스템의 규모가 커질수록 서비스에 대한 안정성, 비용에 대한 압박으로 인해 **변화에 소극적으로 변하는 모습을 목격**했습니다.

이러한 환경에서 변화를 도모하기 위해서는 단순히 다른 조직의 사례를 쫓는 것 보다는, **조직의 맥락(기술적 성숙도, 운영 역량 등)에 맞는 구체적이고 실행 가능한 대안**과 그 대안이 실제로 동작한다는 증명이 필요했습니다.

```
❌ "다른 조직들이 다 MSA로 전환한 걸 보니 괜찮은 것 같아 우리도 MSA로 전환하자"
✅ "이미 도메인별 모듈 분리가 되어 있던 조직들과 달리 우린 아직 도메인이 비즈니스 로직에서 분리되지 않았으니, 모듈러 모놀리스로 먼저 전환해보자" 
```

때문에 **이론이 아닌 실제 동작하는 시스템**을 통해 변화의 가능성을 증명하고, **조직을 설득할 수 있는 구체적 근거**를 만들고자 했습니다.
### 3. 개인적 성장의 계기
3년간 소프트웨어 엔지니어로 근무하며, 가능한 많은 것을 경험하고 많은 시도를 하기 위해 노력은 하였으나, 레거시 시스템의 제약 사항으로로 인해 **새로운 기술의 도입이나 아키텍처 실험의 기회가 제한되었고, 현대적인 개발 프로세스(CI/CD, 테스트 자동화 등)을 경험하기 어려웠습니다.**

이와 더불어 공공기관, 금융권 등 제약이 많은 환경에서 **한정된 기술 스택 만으로 업무를 진행**해 왔기에, **최신 기술 트렌드와 점점 멀어지는 것 같은 불안감**이 있었습니다.

> ***"Kotlin, JPA, k8s를 개념적으로는 알고 있는데 실제로 써본 적이 없네"***  
> ***DDD, TDD, EDA, CQRS를 레거시 환경에 맞춰서 적용해보긴 했는데 다른 환경에서도 똑같이 통할까?"***  
> ***"다른 3년차 백엔드 개발자와 비교했을 때 나의 능력과 경험이 경쟁력이 있을까?"***  

이런 고민 들은 개발자로서의 성장을 위한 하나의 동기가 되었고, **레거시 시스템의 제약적인 환경을 넘어 현대적 기술 스택을 실무 맥락에서 학습하고 적용**하며 **경험해보지 못했던 부분을 경험하고 부족한 부분을 보완하는 계기**로 삼고자 합니다.

---
## 이 프로젝트의 궁극적인 목표
본 프로젝트는 크게 **현대적 기술 스택에 대한 학습**과 **시스템 전환을 위한 PoC** 두 가지에 목표를 두고 있으며, 각 각의 목표는 아래와 같은 세부 목표를 가지고 있습니다.
### 1. 현대적 기술 스택 학습
#### 1) 비교 학습을 통한 맥락 이해
레거시 시스템의 **한계를 이해**하고, 현대적 기술 스택을 통해 **해결할 수 있는 부분을 비교 학습**하며 **전환 과정에서 발생하는 Trade-Off를 이해**하는 것을 목표로 합니다.
```
- Mybatis의 명시적 SQL과 Spring JPA의 추상화는 각 각 어느 상황에서 유리한가?
- Oracle RAC의 고가용성, 데이터 일관성과 PostgreSQL의 경량화, 확장성 중 우리에게 더 필요한 것은?
- Json-RPC의 단일 엔드포인트와 Restful API의 자원 중심 설계는 어떤 장·단점이 있는가?  
```
#### 2) 깊이 있는 이해
단순히 현대 구현체를 사용해보고 끝나는 것이 아닌, **사용된 기술에 대한 원리**를 이해하고 **상황에 따라 발생하는 명확한 장·단점을 이해**하는 것을 목표로 합니다.
```
- Spring Modulith의 모듈 경계 검증 원리와 ArchUnit의 비교
- JPA N+1 문제가 발생하는 이유와 해결 방법(Fetch Join, @EntityGraph, Batch Size 등)
- Kotlin Coroutines의 경량 스레드 모델과 Java 21의 버추얼 스레드의 차이와 상황별 실익
- PostgreSQL의 MVCC와 Oracle의 Undo 방식 차이, 데이터 동기화 시 장·단점
```
### 시스템 전환을 위한 PoC(Proof Of Concept)
#### 1. 현실적인 대안 제시
이상적인 상황을 가정한 대안이 아닌 **현재 시스템의 상황과 조직의 기술적 성숙도, 운영 역량을 기반**으로 실제 **전환 개발과 운영 및 유지·보수가 가능한 대안을 제시**하는 것을 목표로 합니다.
```
❌ MSA와 Kafka를 도입하여 모든 문제를 한번에 해결
✅ 현재 시스템이 전통적인 모놀리스 시스템임을 감안해 모듈러 모놀리스로 시작하되, 향후 MSA 전환이 가능하도록 도메인 경계를 명확히 설정

❌ Redis를 도입해 캐싱과 분산락을 적용
✅ 인프라의 추가 구성이 불가함을 감안해 JPA의 1차 캐시와 애플리케이션 단의 2차 캐시를 통해 조회 속도를 확보하고, 자원교착은 Insert Only를 적용한 불변성 테이블 스키마로 해결
```
#### 2. 현대적 개발 프로세스의 설계와 적용
코드 저장소의 관리, 테스트 프레임워크의 활용, CI/CD 등 **레거시 시스템에는 적용되어 있지 않으나, 시스템의 품질 강화에 필수적인 현대적 업무 프로세스를 환경에 맞게 설계하고 적용**하는 것을 목표로 합니다.
```
- Git Branch 전략: Trunk-based 기반 브랜치 관리
- 테스트 자동화: 단위 테스트, 통합 테스트, E2E 테스트 구분
- CI/CD 파이프라인: GitHub Actions를 통한 자동화된 빌드, 테스트, 배포
- 코드 품질 관리: Ktlint, Detekt를 통한 정적 분석
- 모니터링: 애플리케이션 매트릭과 로그 수집 전략
```
---
## 기술 스택 변경 사항
본 섹션은 시스템의 **구현에 사용되는 기술 스택과 의사결정 배경을 설명**합니다. 구체적인 구현 방법(코드, 설정 등)은 [구현 상세](구현-상세) 섹션에서 확인하실 수 있습니다.
### 1. 구현 언어: Java(11) → Kotlin
레거시 시스템은 Java를 기반으로 하지만 기존 C 기반의 시스템의 구조를 복제하여 만든 시스템으로 C와 Java의 언어적 차이를 적절히 반영하지 못하여 **`NPE(Null Pointer Exception)`가 간헐적으로 발생**하고 있었으며, 이와 더불어 불필요한 객체 생성(방어적 복사, Boxing 등) 등으로 **메모리 관리가 적절히 되지 않아 `Full GC`또한 빈번히 발생**하고 있었습니다. 

코틀린(Kotlin)은 Java에 비해 비교적 최근 도입되기 시작한 언어로 짧은 역사에도 불구하고 **`Null Safety`와 메모리 효율적 연산(inline functions, Sequences 등)의 용이성**을 인정받아 많은 조직에서 사용되고 있으며, **JVM 환경에서 Java와 완전한 호환성을 가지고 있어 기존 시스템의 중단 없이 점진적 전환이 가능**합니다.

이와 더불어 구현 편의성이 강화된 Java 17+와 비교해도 간결한 문법과 완만한 학습곡선을 가지고 있어 **장기적인 관점에서 시스템의 유지보수에 큰 이점**을 줄 수 있을 것이라 생각되어 코틀린을 사용하여 구현하였습니다.

> ***그냥 Java 17+를 사용해도 되는 것 아닌가요?***  
> Java 17+도 Record, Pattern Matching 등으로 불필요한 보일러 플레이트를 줄여 생산성이 많이 개선되었지만,  
> **Null Safety에 대해서는 여전히 컴파일 타임에 미리 방지 할 수 없다는 점**과 비동기 처리 등에서
> 코틀린(Coroutines 등)이 Java(CompletableFuture, Flow 등)에 비해 훨씬 직관적여서 **오용 가능성이 더 낮을 것이라 판단**했습니다.
### 2. 웹프레임워크: BX Framework(5) → Spring Boot
레거시 시스템은 웹프레임워크로 Spring Framework 5.X 버전을 래핑한 상용 프레임워크를 사용하고 있었고, **Spring과 관련된 별도의 설정은 프레임워크 벤더사에 전적으로 의존**하고 있었습니다.

이로 인해 프레임워크 벤더사가 정한 특정 형식의 설정을 벗어날 수 없었고, 때문에 **Spring의 메이저 업데이트로 인한 설정 변경이 필요할 시 이에 대한 반영이 사실상 불가**했습니다, 이와 더불어 Spring AOP(AspectJ)를 사용할 수 없다는 치명적인 단점을 가지고 있어 Spring의 이점을 충분히 누리지 못하고 있는 실정이었습니다.

때문에 본 프로젝트에서는 프레임워크의 **벤더 의존성을 줄이고, 설정 등에 대한 사용성을 확보**하기 위해 Spring Boot를 사용하여 구현하기로 하였으며, 서비스 간 독립성 확보를 위해 WAS를 통한 **전체 서비스의 일괄 배포가 아닌 도메인 단위 배포를 적용**하였습니다.
### 3. 관계형 데이터베이스: Oracle(12c) → PostgreSQL
레거시 시스템의 데이터베이스는 상용 데이터베이스인 **Oracle을 RAC 구성**을 통해 다수의 인스턴스가 동일한 스토리지를 공유하며 **전체 인스턴스에 대한 데이터 일관성을 유지**하고 있었습니다.

허나, **높은 라이선스 비용**과 **벤더 종속성**으로 인해 컴퓨팅 자원 확장 시 비용이 급증하고, **Oracle 전용 문법(PL/SQL, 힌트 등)으로 작성된 프로그램의 마이그레이션에 제약**이 있었고 이와 더불어 컨테이너 환경 지원이 제한적이고 ORM과의 호환성이 완벽하지 않아 **현대적인 개발 방식과 충돌**하는 모습을 보이고 있었습니다.

이와 달리 `PostgreSQL`은 **`Oracle`과 유사한 문법**을 가지고 있어 레거시 시스템 담당자의 학습 부담이 적고, **오픈소스이기에 비용 부담 없이 확장**할 수 있습니다. 또한 **`JSON`/`JSONB` 타입**을 네이티브로 지원하여 유연한 데이터 모델링이 가능하고, Docker 환경과 JPA 모두 완벽히 지원하여 **현대적 개발 환경에 적합**하기에 PostgreSQL을 사용하여 구현하였습니다.

> ***왜 MySQL이 아닌 PostgreSQL인가요?***  
> `MySQL`도 널리 사용되고 있는 오픈소스 데이터베이스지만,
> 본 프로젝트에서는 `Oracle`에서의 마이그레이션 관점에서 `Oracle`과 문법적 유사도가 높은  
> `PostgreSQL`이 쿼리 로직의 변환과 학습 곡선 면에서 더 적합하다고 판단했습니다.
### 4. 영속성 프레임워크: Mybatis → Hibernate + Query DSL
레거시 시스템은 영속성 프레임워크로 `SQL Mapper`인 `Mybatis`를 사용하고 있었습니다. 이는 기존 복합한 스키마를 가지는 테이블 간 조인을 쉽게 처리하고, 쿼리 작성 시 **다양한 집계 함수나 명시적 힌트 사용을 통해 높은 성능을 보장**할 수 있도록 하고있었습니다.

다만, 프레임워크의 구조상 **데이터베이스에 대한 과한 의존성**을 만들어 애플리케이션 계층의 축소와 실시간성 테스트의 어려움을 가져왔고, **개발자의 쿼리 작성 수준에 따라 서비스 전체의 성능이 결정**되는 등의 문제를 가지고 있었습니다.

이와 달리 JPA 구현체의 일종인 `Hibernate`는 복잡한 집계 쿼리의 작성이나 힌트의 적용과 같은 부분이 제약을 받지만, `ORM`을 통한 엔티티 ↔ 스키마간 매핑으로 애플리케이션 계층에 **도메인 동작의 실행을 위임**할 수 있고, **기본적으로 작성되는 CRUD 쿼리와 1차 캐싱을 통해 개발자의 쿼리 작성 능력과 상관없이 일정한 수준의 서비스를 제공**할 수 있기에 `Hibernate` + `Query DSL`로 구현하였습니다.

> ***Hibernate와 Query DSL은 각 각 어느 상황에서 사용하나요?***  
> **`Hibernate`는 `Command`의 처리 혹은 간단한 CRUD에 사용**하여 영속성 컨텍스트의 이점(변경 감지, 1차 캐시 등)을 최대한 살리고, **`Query DSL`은 읽기 성능이 중요한 조회에서 사용**하여 복합한 집계와 다중 조인을 명시적으로 처리하도록 하였습니다.

---
## 아키텍처 변경 사항
본 섹션은 시스템 **재설계의 방향성과 의사결정 배경을 설명**합니다. 구체적인 구현 방법(코드, 설정 등)은 [구현 상세](구현-상세) 섹션에서 확인하실 수 있습니다.
### 1. 시스템 아키텍쳐: 모놀리스 → 모듈러 모놀리스
레거시 시스템은 전형적인 `Big Ball of Mud` 형태의 모놀리스 시스템으로 **하나의 애플리케이션 안에 비즈니스 로직, 도메인, 데이터 접근 등이 전부 결합**되어 있고 하나의 프로세스로 배포되는 구조로 되어있었습니다.

이러한 강결합으로 인해 **하나의 서비스 내에서도 부분의 오류가 전체의 오류로 전파**되고 있었으며, 도메인 영역에 대한 식별이 불가해 **모든 서비스에서 동일한 도메인이 다르게 정의**되고 있는 문제 또한 발생하고 있는 실정이었습니다.

때문에 이를 해결하기 위해 도메인 영역을 기반으로 모듈을 분리하는 방향으로 접근하였으며, 도메인 주도 설계(Domain Driven Design)와 Spring Modulith를 통해 **도메인을 비즈니스 로직과 데이터 접근에서 완전히 격리**시켜 향후 **아키텍처나 프레임워크에 변화에도 도메인의 불변성을 보장할 수 있도록 구현**하였습니다.

> ***왜 MSA가 아닌 모듈러 모놀리스 시스템 아키텍처인가요?***  
> 레거시 시스템의 아키텍처에서 MSA로 바로 넘어가기 위해서는 인프라, 네트워킹, 서비스 구조 등이 모두 바뀌어야 하나,
> 현재 **조직의 기술적 성숙도와 운영 역량을 고려**했을때, 현 시점에서는 **구조적 문제를 해결할 수 있는 모듈러 모놀리스로의 점진적 전환을 우선**하고,
> 향후 MSA 전환을 위해 도메인 영역을 명확히 분리하는 것이 맞다고 판단했습니다.
### 2. 서비스 호출: Json-RPC → RESTful API
레거시 시스템의 경우 개발의 편의를 위해 모태가 되는 시스템의 `Client` ↔ `AP` 호출 방식을 그대로 계승하여 서비스 호출에 **서비스코드 기반 `Json-RPC`를 사용**하고 있었습니다.

이러한 통신 구조는 **`http`의 `POST` 방식을 사용해 단일 서비스 포인트에 접근**했기에 `gRPC`등의 바이너리 통신에 비해 느릴 수 밖에 없었고, `http`요청에 대한 캐싱이 어려워 `RESTful API`에 비해서도 상대적으로 느릴 수 밖에 없었습니다. 이와 더불어 **모든 응답을 `http`의 응답코드가 아닌 `body`에 적재하는 탓에 응답에 대한 일관성을 유지할 수 없는 상황**이었습니다.

다만, 현재 서비스의 경우 **캐싱되지 않은 `Json-RPC`방식을 사용함에도 전체 요청을 충분히 처리할 수 있는 성능**을 보여주고 있었고 **타 시스템과의 연동, 외부 기관과의 연계 요건이 다수 존재**했기에 **범용성에 초점**을 맞춰 `gRPC`대신 **`RESTful API` 방식의 서비스 호출 형식으로 구현**했습니다.
### 3. 서비스 간 통신: 함수 호출 → 비동기 이벤트
레거시 시스템은 서비스 간 통신 시 타 업무 도메인의 객체에 대한 의존성을 주입하고 직접 호출하는 방식을 사용하고 있었으며, 이는 **도메인 간 결합도를 증가시켜 단 하나의 도메인에서 발생한 오류가 전체 서비스를 마비 시키는 상황을 발생**시키고 있었습니다.

이와 더불어 타 업무 **도메인 호출이 모두 동기 형식**으로 구현되어 있었기에 **다수의 도메인에 연계가 필요한 서비스는 과도한 대기 시간**을 가져 큰 성능 하락을 불러오고 있었습니다.

때문에, 이런 문제를 해결하고자 **비동기 이벤트 통신 방식을 적용**하고자 하였으며, `RabbitMQ`나 `Kafka`와 같은 **이벤트 큐/스트리밍을 사용하기 위한 인프라의 구성이 불가**하고, **`SAGA` 패턴을 적용할 정도의 기술적 성숙도가 되지 않는다 판단**하여 **`Application Context` 기반 이벤트 통신을 적용**하였습니다.
### 4. 데이터 관계: N:N PK 기반 → 1:N, N:N FK 기반
레거시 시스템의 테이블은 하나의 거래를 식별할 수 있는 다수의 데이터 묶음을 모두 `Primary Key(PK)`로 설정해 이를 연계되는 모든 테이블에 동일하게 적용하는 **`N:N PK`기반 테이블 설계가 적용**되어 있었습니다.

이는 **테이블 스키마 구성의 일관성**을 주고, 자동 생성되는 **`PK`인덱스로 인해 최소한의 조회 속도를 보장**할 수 있지만, **데이터를 통해 관계를 명확히 볼 수 없고 테이블의 정규화, `Object Relation Mapper(ORM)`의 활용을 어렵게 하는 등의 문제**를 가지고 있었습니다.

때문에 이를 방지하고자 테이블을 **`Id` 기반의 단일 `PK`테이블로 재설계** 하고, **테이블 간 관계를 `Foreign Key(FK)`로 정의**하였으며, **`PK`기반 단일 복합 인덱스를 조건에 맞는 복수 인덱스로 구성**해 조회 속도를 확보하는 형태로 구현하였습니다.
### 5. 테이블 스키마: 단일 비정규화 테이블 → CQRS 적용 역할 분리
레거시 시스템의 테이블은 하나의 기능에 대해 **읽기와 쓰기를 모두 단일 비정규화 테이블을 사용해 처리**하였고, 서비스 요건의 추가에 따라 **컬럼과 인덱스를 지속적으로 추가만** 되고 있는 상황이었습니다.

이로 인해 **서비스 기간이 길어짐에 따라 읽기 성능이 점차 하락**하는 현상이 발생하고 있었으며 이와 더불어 **쓰기 동작 시 예상치 못한 자원교착 등의 문제가 추가적으로 발생**하고 있었습니다.

때문에 이를 방지하고자 `Command`와 `Query`의 역할을 명확히 분리하기 위해 `DB`를  용도에 따라 분리하였으며, Logical Replication을 이용해 **`Command`를 위한 테이블은 정규화를 통해 체계적인 데이터의 관리**, **`Query`를 위한 테이블은 부분 비정규화와 파티션, 인덱스를 통한 조회 성능 확보에 초점**을 두어 구현하였습니다.

> ***DB 전체를 분리하면 데이터 일관성에 문제가 생기지 않을까요?***
> 사용자의 데이터 이용 패턴을 분석해 보았을 때, **대부분의 사용자는 조회 전용 서비스를 "실적 관리용"으로 사용**하고 있어 실시간 복제가 보장되지 않아도 되었으며, 주문, 매출 등의 **실시간성 데이터는 `command`DB를 통해 직접 조회**해 데이터 일관성에 문제가 생기지 않을 것이라 판단했습니다.
---
## 프로젝트의 범위와 제약 사항
### 1. 구현 범위
본 프로젝트는 실제 운영 중인 주유소 관리 시스템의 **핵심 도메인을 재설계**한 것으로, 다음 기능을 포함합니다.

- **주유소 및 지점 관리**
- **유류 재고 관리**
- **판매 및 정산 처리**
- **회원 및 포인트 관리**
- **고정자산 관리**
- **점검 관리**
### 2. 의도적으로 제외한 부분
**기술적 의사결정과 아키텍처의 설계, 현대 기술 스택의 활용에 집중**하기 위해 실제 시스템에서 구현되었어야 할 부분 중 일부를 **의도적으로 제외**하였습니다.

- **외부 연동**: VAN사, 카드사, 공공기관, 국세청 등 외부 기관 연동은 Mock으로 대체하였습니다.
- **레거시 호환**: 레거시 시스템을 구현할 수 없기에 관련 연동 및 호환 확인은 제외하였습니다.
- **완전한 운영 환경**: 운영 환경 수준의 보안, 모니터링, 장애 대응은 간소화 하였습니다.
---
## 개발 프로세스
### 1. Git 브랜치 전략
- **Trunk-based Development**: main 브랜치를 단일 진실 공급원으로 합니다.
- Feature 브랜치에서 개발 후 PR을 통해 main에 병합
- 커밋 규칙: Conventional Commits를 준수합니다.
### 2. 테스트 전략
- **단위 테스트**: Junit5와 MockK를 이용한 테스트 코드로 작성하고 수행합니다.
- **통합 테스트**: Testcontainers를 활용해 실제 DB 환경 테스트를 수행합니다.
- **E2E 테스트**: RestAssured를 활용한 API 테스트를 수행합니다.
```
목표 커버리지
  - (도메인 영역) 100%
  - (비즈니스 로직) 80% 이상
```
### 3. CI/CD 파이프라인
- **지속적인 통합(CI, Continuous Integration)**: GitHub Actions를 통해 자동 빌드 및 테스트를 수행합니다.
- **지속적인 배포(CD, Continuous Deployment)**: Docker 이미지를 빌드하고 배포를 자동화합니다.
- **코드 품질**: Ktlint, Detekt을 통한 정적 분석을 수행합니다.

### 4. 코드 리뷰
- **AI 리뷰어 활용**: Pull Request(PR) 시 AI 리뷰어를 활용해 리뷰를 진행합니다. 
- **주 단위 셀프 리뷰**: 매주 전체 PR에 대한 셀프 리뷰 및 회고를 진행합니다.
---
## 실행 방법
### 1. 사전 요구사항
- **JDK 17 이상**
- **Docker & Docker Compose**
- **Gradle 8.5 이상**
### 2. 로컬 환경 실행
```bash 
# 1. 저장소 클론 
git clone https://github.com/your-repo/gas-station-management.git 
cd gas-station-management 

# 2. PostgreSQL 실행 (Docker Compose) 
docker-compose up -d 

# 3. 애플리케이션 실행 
./gradlew bootRun 

# 4. API 문서 확인 
http://localhost:8080/swagger-ui.html 
``` 
### 3. 테스트 실행 
```bash 
# 1. 전체 테스트 
./gradlew test 

# 2. 통합 테스트만 실행 
./gradlew integrationTest 
```
