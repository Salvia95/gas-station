# 주유소 관리 시스템(Gas Station Management System)
실무에서 마주한 문제 상황과 앞으로 마주할 것이 예상되는 문제 사항에 대한 해결을 위해 레거시 시스템의 구조적, 기술적 한계를 분석하고 **현대적 기술 스택과 아키텍처를 적용해 재설계한 프로젝트** 입니다.
## 목차

1. [프로젝트 동기](#프로젝트-동기)
2. [주요 기술스택](주요-기술스택)
3. [기술적 의사결정](#기술적-의사결정)
4. [아키텍처](#아키텍처)
5. [주요 구현사항](#주요-구현사항)
6. [개발 프로세스](#개발-프로세스)
7. [실행 방법](#실행-방법)
## 프로젝트 동기
### 실무에서 마주한 문제와 의문
Java 11, Spring Framework 5.X, Oracle 12c, Mybatis를 사용하고 있는 레거시 시스템을 유지보수하는 과정에서 마주했던 **대다수의 문제는 기존 기술 스택 안에서 해결**할 수 있었습니다.
허나, 간혹 마주하는 **시스템의 구조적인 문제**는 

**지속적으로 떨어지는 생산성**, **지수적으로 증가하고 있는 기술 부채**의 문제는 **근본적으로 해결되지 않고 있었고**, 그 누구도 이를 해결할 수 있다고 말하거나, 해결해보고자 하는 시도를 하지 않았기에 정말 해결이 불가한 
### 변화를 설득하기 위한 근거의 필요성
조직과 시스템의 규모가 커질수록 서비스에 대한 안정성, 비용에 대한 압박으로 인해 변화에 소극적으로 변하는 모습을 보인다고 생각합니다.
이러한 환경에서 변화를 도모하기 위해서는 단순히 다른 조직의 사례를 쫓는 것 보다는 
## 이 프로젝트의 목표
본 프로젝트는 크게 **현대적 기술 스택에 대한 학습**과 **시스템 전환을 위한 PoC** 두 가지에 목표를 두고 있으며, 각 각에 대해서는 아래와 같은 세부 목표를 가지고 있습니다.
### 현대적 기술 스택 학습
#### 1. 비교 학습
레거시 시스템의 **한계를 이해**하고, 현대적 기술 스택을 통해 **해결할 수 있는 부분을 비교 학습**하며 **전환 과정에서 발생하는 Trade-Off를 이해**하는 것을 목표로 합니다.
#### 2. 깊이 있는 이해
단순히 현대 구현체를 사용해보고 끝나는 것이 아닌, **사용된 기술에 대한 원리**를 이해하고 **상황에 따라 발생하는 명확한 장·단점을 이해**하는 것을 목표로 합니다.
### 시스템 전환을 위한 PoC
#### 1. 현실적인 대안 제시
이상적인 상황을 가정한 대안이 아닌 **현재 시스템의 상황과 조직의 기술적 성숙도를 기반**으로 실제 **전환 개발과 운영 및 유지·보수가 가능한 대안을 제시**하는 것을 목표로 합니다.
#### 2. 업무 프로세스의 설계
코드 리뷰, 테스트 프레임워크의 활용, CI/CD 등 **평소 경험할 수 없었으나 시스템의 품질 강화에 필수적인 현대적 업무 프로세스를 환경에 맞게 설계하고 경험**하는 것을 목표로 합니다.
## 기술 스택 변경 사항
본 프로젝트는 레거시 시스템의 기술 스택에서 현실적인 전환이 가능하면서, **현재 발생하고 있는 문제를 보다 적절히 해결할 수 있는 현대적 기술 스택으로 전환하는 것에 초점**을 두고 있으며, 각 각의 기술 스택은 아래와 같이 변경하였습니다.
### 1. 구현 언어: Java(11) → Kotlin
### 2. 웹프레임워크: Spring Framework(5) → Spring Boot
### 3. 관계형 데이터베이스: Oracle(12c) → PostgreSQL
### 4. 영속성 프레임워크: Mybatis → Hibernate + Query DSL

> 레거시 시스템에 적용된 기술 스택의 한계와 새로 선정된 기술 스택의 선택 근거 등은 [기술적 의사결정](기술적-의사결정)에서 확인하여 주시기 바랍니다.
## 아키텍처 변경 사항

### 1. 시스템 아키텍쳐: 모놀리스 → 모듈러 모놀리스
레거시 시스템은 전형적인 `Big Ball of Mud` 형태의 모놀리스 시스템으로 **하나의 애플리케이션 안에 비즈니스 로직, 도메인, 데이터 접근 등이 전부 결합**되어 있고 하나의 프로세스로 배포되는 구조로 되어있었습니다.

이러한 강결합으로 인해 **하나의 서비스 내에서도 부분의 오류가 전체의 오류로 전파**되고 있었으며, 도메인 영역에 대한 식별이 불가해 **모든 서비스에서 동일한 도메인이 다르게 정의**되고 있는 문제 또한 발생하고 있는 실정이었습니다.

때문에 이를 해결하기 위해 도메인 영역을 기반으로 모듈을 분리하는 방향으로 접근하였으며, 도메인 주도 설계(Domain Driven Design)와 Spring Modulith를 통해 **도메인을 비즈니스 로직과 데이터 접근에서 완전히 격리**시켜 향후 **아키텍처나 프레임워크에 변화에도 도메인의 불변성을 보장할 수 있도록 구현**하였습니다.

> ***왜 MSA가 아닌 모듈러 모놀리스 시스템 아키텍처인가요?***  
> 레거시 시스템의 아키텍처에서 MSA로 바로 넘어가기 위해서는 인프라, 네트워킹, 서비스 구조 등이 모두 바뀌어야 하나, 현재 **조직의 기술적 성숙도와 운영 역량을 고려**했을때, 현 시점에서는 **구조적 문제를 해결할 수 있는 모듈러 모놀리스로의 점진적 전환을 우선**하고, 향후 MSA 전환을 위해 도메인 영역을 명확히 분리하는 것이 맞다고 판단했습니다.
### 2. 서비스 호출: Json-RPC → RESTful API
레거시 시스템의 경우 개발의 편의를 위해 모태가 되는 시스템의 `Client` ↔ `AP` 호출 방식을 그대로 계승하여 서비스 호출에 **서비스코드 기반 `Json-RPC`를 사용**하고 있었습니다.

이러한 통신 구조는 **`http`의 `POST` 방식을 사용해 단일 서비스 포인트에 접근**했기에 `gRPC`등의 바이너리 통신에 비해 느릴 수 밖에 없었고, `http`요청에 대한 캐싱이 어려워 `RESTful API`에 비해서도 상대적으로 느릴 수 밖에 없었습니다. 이와 더불어 **모든 응답을 `http`의 응답코드가 아닌 `body`에 적재하는 탓에 응답에 대한 일관성을 유지할 수 없는 상황**이었습니다.

다만, 현재 서비스의 경우 **캐싱되지 않은 `Json-RPC`방식을 사용함에도 전체 요청을 충분히 처리할 수 있는 성능**을 보여주고 있었고 **타 시스템과의 연동, 외부 기관과의 연계 요건이 다수 존재**했기에 **범용성에 초점**을 맞춰 `gRPC`대신 **`RESTful API` 방식의 서비스 호출 형식으로 구현**했습니다.
### 3. 서비스 간 통신: 함수 호출 → 비동기 이벤트
레거시 시스템은 서비스 간 통신 시 타 업무 도메인의 객체에 대한 의존성을 주입하고 직접 호출하는 방식을 사용하고 있었으며, 이는 **도메인 간 결합도를 증가시켜 단 하나의 도메인에서 발생한 오류가 전체 서비스를 마비 시키는 상황을 발생**시키고 있었습니다.

이와 더불어 타 업무 **도메인 호출이 모두 동기 형식**으로 구현되어 있었기에 **다수의 도메인에 연계가 필요한 서비스는 과도한 대기 시간**을 가져 큰 성능 하락을 불러오고 있었습니다.

때문에, 이런 문제를 해결하고자 **비동기 이벤트 통신 방식을 적용**하고자 하였으며, `RabbitMQ`나 `Kafka`와 같은 **이벤트 큐/스트리밍을 사용하기 위한 인프라의 구성이 불가**하고, **`SAGA` 패턴을 적용할 정도의 기술적 성숙도가 되지 않는다 판단**하여 **`Application Context` 기반 이벤트 통신을 적용**하였습니다. 
### 4. 데이터 관계: N:N PK 기반 → 1:N, N:N FK 기반
레거시 시스템의 테이블은 하나의 거래를 식별할 수 있는 다수의 데이터 묶음을 모두 `Primary Key(PK)`로 설정해 이를 연계되는 모든 테이블에 동일하게 적용하는 **`N:N PK`기반 테이블 설계가 적용**되어 있었습니다.

이는 **테이블 스키마 구성의 일관성**을 주고, 자동 생성되는 **`PK`인덱스로 인해 최소한의 조회 속도를 보장**할 수 있지만, **데이터를 통해 관계를 명확히 볼 수 없고 테이블의 정규화, `Object Relation Mapper(ORM)`의 활용을 어렵게 하는 등의 문제**를 가지고 있었습니다.

때문에 이를 방지하고자 테이블을 **`Id` 기반의 단일 `PK`테이블로 재설계** 하고, **테이블 간 관계를 `Foreign Key(FK)`로 정의**하였으며, **`PK`기반 단일 복합 인덱스를 조건에 맞는 복수 인덱스로 구성**해 조회 속도를 확보하는 형태로 구현하였습니다.
### 5. 테이블 스키마: 단일 비정규화 테이블 → CQRS 적용 역할 분리
레거시 시스템의 테이블은 하나의 기능에 대해 **읽기와 쓰기를 모두 단일 비정규화 테이블을 사용해 처리**하였고, 서비스 요건의 추가에 따라 **컬럼과 인덱스를 지속적으로 추가만** 되고 있는 상황이었습니다.

이로 인해 **서비스 기간이 길어짐에 따라 읽기 성능이 점차 하락**하는 현상이 발생하고 있었으며 이와 더불어 **쓰기 동작 시 예상치 못한 자원교착 등의 문제가 추가적으로 발생**하고 있었습니다.

때문에 이를 방지하고자 `Command`와 `Query`의 역할을 명확히 분리하기 위해 테이블 스키마를 용도에 따라 분리하였으며, **`Command`를 위한 테이블은 정규화를 통해 체계적인 데이터의 관리**, **`Query`를 위한 테이블은 부분 비정규화와 파티션, 인덱스에 초점**을 두어 구현하였습니다.

> ***왜 DB 인프라 전체를 분리하는 CQRS가 아닌 테이블만 분리하는 CQRS 인가요?***  
> DB 자체를 분리하게 되면 `Query`담당 테이블에 대한 일관성 유지가 문제가 될 수 있는데 현재는 이를 적절히 처리하기 위한 **Kafka와 같은 이벤트 브로커, Flink, Debizium과 같은 CDC를 사용할 수 있는 인프라와 기술적 성숙도가 갖춰져 있지 않았기에** 인프라 분리를 고려하지 않았으며, 단순 스키마 개선 만으로도 인덱스 구성과 자원교착 문제에서 큰 이점을 가질 수 있다 생각했습니다.
## 기술적 의사결정

### 1. 구현 언어: Java → Kotlin
#### 기존 언어(Java)의 특징
```
- 오랜기간 사용된 기술 스택으로 인력 변경에 의한 리스크 없음
- 다양한 프레임워크(라이브러리) 지원과 풍부한 레퍼런스
```
#### 기존 언어(Java)의 한계
```
- Java 17+ 이후 수많은 편의성 개선에도 불구하고 상대적으로 많은 보일러플레이트
- NPE(NullPointerException)로 인한 예상치 못한 오류 상황의 발생
```
#### 현실적인 대안(Kotlin)
```
- 쉬운 문법과 다양한 편의성 기능으로 인한 완만한 학습곡선
- 프레임워크 단에서 지원하는 Null Check를 통한 NPE 방지
- JVM 생태계를 사용하는 언어로 Java에서 점진적 전환 가능
```
#### Trade-Off 분석
코틀린(Kotlin)은 비교적 최근 도입되기 시작한 언어로 **외부인력 수급에 분명한 리스크가 존재**하지만, **JVM 환경에서 Java와의 완전한 호환성을 가지고 있어 기존 시스템의 변경 없이 점진적 도입이 가능**하고, 간결한 문법과 완만한 학습곡선으로 **장기적인 관점에서 시스템의 유지보수에 큰 이점**을 줄 수 있을 것이라 생각되어 코틀린을 사용하는 것으로 결정하였습니다.

### 2. 관계형 데이터베이스: Oracle → PostgreSQL
#### 기존 데이터베이스(Oracle)의 특징
```
```
#### 기존 데이터베이스(Oracle)의 한계
```
- 벤더 종속성으로 인해 자유로운 확장 및 업그레이드 불가
- 고유 기능으로 인해 향후 데이터베이스 전환 시 추가 분석 및 구현 비용 발생
```
#### 현실적인 대안(PostgreSQL)
```
- 오픈소스 데이터베이스로 자유로운 확장 및 업그레이드 가능
- 비정형데이터 취급을 위한 JSONB, 벡터 DB 구성을 위한 pgvector 등의 확장 프로그램 활용 가능
```
#### Trade-Off 분석
PostgreSQL은 현재 **MySQL과 같이 가장 많이 사용되고 있는 오픈소스 관계형 데이터베이스 중 하나**로, **Oracle과 거의 유사한 문법을 가지고 있어 마이그레이션 및 인력 수급이 용이**하고, JSON을 기존 레코드 처럼 활용할 수 있는 JSONB 컬럼과 벡터 DB 구성을 위한 pgvector 등이 **향후 AI 활용에서 큰 이점**을 줄 수 있을 것이라 생각되어 PostgreSQL을 사용하는 것으로 결정하였습니다. 

### 3. 영속성 관리: Mybatis(QueryMapper) → Hibernate(JPA) + Query DSL
#### 기존 영속성 관리(Mybatis)의 특징
```
- 
```
#### 기존 영속성 관리(Mybatis)의 한계
```
```
#### 현실적인 대안(Hibernate(JPA) + Query DSL)
```
```
#### Trade-Off 분석


## 아키텍처

### 1. 인프라 구성(3-Tier On-Prem → Cloud Native)
#### 기존 인프라 구성(3-Tier On-Prem)의 특징
```
- 
```

### 2. DB 스키마 구성(N:N PK → 1:N OR N:1 PK)
#### 기존 DB 스키마 구성(N:N PK)의 특징
```

```

## 주요 구현사항

## 개발 프로세스

## 실행 방법
